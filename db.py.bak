# db.py (Add this function)

import sqlite3
import datetime
import logging

DATABASE = 'monitoring_data.db'
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# ... (get_db, init_db, add_or_update_abnormality - keep as before) ...

def get_latest_unresolved_abnormality_id(container_id, log_snippet=None):
    """Finds the ID of the most recent 'unresolved' abnormality for a container."""
    conn = get_db()
    cursor = conn.cursor()
    try:
        # Prioritize matching snippet if provided, otherwise just latest for container_id
        if log_snippet:
             # This UNIQUE constraint helps find the specific recurring issue
             cursor.execute("""
                SELECT id FROM abnormalities
                WHERE container_id = ? AND log_snippet = ? AND status = 'unresolved'
                ORDER BY last_detected_timestamp DESC
                LIMIT 1
             """, (container_id, log_snippet))
        else:
            # Fallback if no specific snippet match needed or found
             cursor.execute("""
                SELECT id FROM abnormalities
                WHERE container_id = ? AND status = 'unresolved'
                ORDER BY last_detected_timestamp DESC
                LIMIT 1
             """, (container_id,))

        result = cursor.fetchone()
        return result['id'] if result else None
    except sqlite3.Error as e:
        logging.error(f"Error fetching latest unresolved abnormality ID for {container_id[:12]}: {e}")
        return None
    finally:
        conn.close()


def get_abnormality_by_id(abnormality_id):
    """Fetches a single abnormality by its ID."""
    conn = get_db()
    cursor = conn.cursor()
    try:
        cursor.execute("SELECT * FROM abnormalities WHERE id = ?", (abnormality_id,))
        abnormality = cursor.fetchone()
        # Convert Row to dict and parse datetime
        if abnormality:
            item = dict(abnormality)
            try:
                item['first_detected_timestamp'] = datetime.datetime.fromisoformat(item['first_detected_timestamp'])
                item['last_detected_timestamp'] = datetime.datetime.fromisoformat(item['last_detected_timestamp'])
            except (ValueError, TypeError): # Handle potential parsing errors
                 item['first_detected_timestamp'] = datetime.datetime.fromtimestamp(0)
                 item['last_detected_timestamp'] = datetime.datetime.fromtimestamp(0)
            return item
        else:
            return None
    except sqlite3.Error as e:
        logging.error(f"Error fetching abnormality by ID {abnormality_id}: {e}")
        return None
    finally:
        conn.close()

# ... (get_abnormalities, update_abnormality_status - keep as before) ...

# No change needed for init_db()
